<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Brian C Tracy Brown University Palo Alto personal website Brian Tracy - endianness-exists"><title>Brian Tracy - endianness-exists</title><link href="data:," rel="icon"><style>main{margin:auto;max-width:48em}pre{background-color:#d3d3d3;padding:1em}code{background-color:#d3d3d3}footer{font-style:italic;margin-top:3em}hr{width:60%}h1,h2,h3,h4,h5{color:#006400}table{border-collapse:collapse;border-spacing:0}th,td{border:2px solid silver;padding:4px}</style></head><body><main><h1>Endianness (Byte Order) Is Real!</h1><p>As a student, I learned about the concept of <a href="https://en.wikipedia.org/wiki/Endianness">endianness / byte order</a> at a very high level. Due to the fact that x86 is a little endian ISA and ARM ISAs are by default little endian, big endian systems simply did not exist to me. In fact, unless I was to do some low level networking, I was confident in the fact that I would never need to use a big endian system while at school.</p><p>Well it turns out that big endian systems do exist, and code that I write one day may have to run on such systems. Knowing this, I wanted to prove to myself that there really was something fundamentally different, and potentially dangerous, about naively targeting these platforms. To do so, I cooked up a sample application and ran it on both a little endian x86 system, and a big endian (emulated via QEMU) MIPS system.</p><hr><p>The application is a fake database type thing where the user inputs some information about themselves that can be read back at a later date.</p><pre><code>$ ./users
usage: ./users create &lt;file&gt; &lt;name&gt; &lt;id&gt; &lt;weight&gt;
usage: ./users fetch &lt;file&gt;</code></pre><p>The <code>create</code> operation puts the user supplied values into a structure, then writes the bytes of the structure to the given file.</p><p>The <code>fetch</code> operation populates a structure directly from the bytes of the given file.</p><p>Here is the user structure:</p><pre><code>struct user {
    char name[8];   // 8 bytes
    uint64_t id;    // 8 bytes
    double weight;  // 8 bytes
};</code></pre><p>Essentially, the <code>create</code> operation is:</p><pre><code>struct user new_user = { /* (name, id, weight) from user input */ };
write(fd, &amp;new_user, sizeof(struct user));</code></pre><p>And the <code>fetch</code> operation is:</p><pre><code>struct user existing_user;
read(fd, &amp;existing_user, sizeof(struct user));</code></pre><p>The goal is to demonstrate how this code, while seemingly "portable" (in the sense that all we are doing is reading/writing from/to a file), will in fact be laid low by the byte order of the underlying hardware.</p><hr><p>The setup is that there are two different systems, one little endian and one big. In addition, on the little endian system, both a 32 and 64 bit version of the program are compiled. We will see that due to the <code>struct user</code> definition, there will be no difference between the 32 and 64 bit programs, but there will be a difference between the two systems.</p><p>For the little endian system, I am running a virtual x64 machine on my personal computer:</p><pre><code>vagrant@ubuntu-focal:~ $ uname -a
Linux ubuntu-focal 5.4.0-73-generic #82-Ubuntu SMP
Wed Apr 14 17:39:42 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>For the big endian system, I am running QEMU to emulate MIPS Debian from within the above virtual machine:</p><pre><code>root@ubuntu-focalqemu:~ # uname -a
Linux ubuntu-focalqemu 4.19.0-16-4kc-malta #1 SMP Debian 4.19.181-1
(2021-03-19) mips GNU/Linux</code></pre><p>Here is an example of the program running normally.</p><pre><code>root@ubuntu-focalqemu:/test# ./mips_users create mips.data brimips 12345 987.654
creating user {&#39;brimips&#39;, id=12345, weight=987.654000} in file mips.data
root@ubuntu-focalqemu:/test# ./mips_users fetch mips.data
found user {&#39;brimips&#39;, id=12345, weight=987.654000} in file mips.data</code></pre><p>In the emulated environment, running the MIPS binary, we get semi garbage data when attempting to read in the little endian x86/64 data:</p><pre><code>root@ubuntu-focalqemu:/test# ./mips_users fetch x86.data
found user {&#39;brix86&#39;, id=4120793659044003840, weight=-0.000000} in file x86.data
root@ubuntu-focalqemu:/test# ./mips_users fetch x64.data
found user {&#39;brix64&#39;, id=4120793659044003840, weight=-0.000000} in file x64.data</code></pre><p>Likewise, on the x86/64 platform, we get incorrect values when attempting to read from the big endian MIPS data.</p><pre><code>vagrant@ubuntu-focal:/vagrant/mips$ ./x86_users fetch mips.data
found user {&#39;brimips&#39;, id=4120793659044003840, weight=-0.000000} in file mips.data
vagrant@ubuntu-focal:/vagrant/mips$ ./x64_users fetch mips.data
found user {&#39;brimips&#39;, id=4120793659044003840, weight=-0.000000} in file mips.data</code></pre><p>Here are the three compilations of the same source program. The MIPS target was compiled on the emulated MIPS host (I could not figure out how to get GCC to cross compile).</p><pre><code>(x64)  $ gcc ${CFLAGS} users.c -o x64_users
(x86)  $ gcc ${CFLAGS} -m32 users.c -o x86_users
(mips) $ gcc ${CFLAGS} users.c -o mips_users</code></pre><p>Where <code>CFLAGS='-Wall -Wextra -Wpedantic -std=c11'</code>. Here are the resulting executables.</p><pre><code>$ file mips_users
ELF 32-bit MSB pie executable, MIPS, MIPS32 rel2 version 1 (SYSV)

$ file x86_users
ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV)

$ file x64_users
ELF 64-bit LSB shared object, x86-64, version 1 (SYSV)</code></pre><p>To understand what is going wrong, take a look at the data files generated by each program. The crux of the issues is that the <code>struct user</code> is being serialized in a platform dependent manner (the dependence being the byte order of the <code>uint64_t</code> and the <code>double</code> fields).</p><pre><code>$ xxd -c8 mips.data
00000000: 6272 696d 6970 7300  brimips.     char name[8]  (&quot;brimips\0&quot;)
00000008: 0000 0000 0000 3039  ......09     uint64_t id   (12345)
00000010: 408e dd3b 645a 1cac  @..;dZ..     double weight (987.654)
$ xxd -c8 x86.data
00000000: 6272 6978 3836 0000  brix86..     char name[8]  (&quot;brix86\0\0&quot;)
00000008: 3930 0000 0000 0000  90......     uint64_t id   (12345)
00000010: ac1c 5a64 3bdd 8e40  ..Zd;..@     double weight
$ xxd -c8 x64.data
00000000: 6272 6978 3634 0000  brix64..     char name[8]  (&quot;brix64\0\0&quot;)
00000008: 3930 0000 0000 0000  90......     uint64_t id   (12345)
00000010: ac1c 5a64 3bdd 8e40  ..Zd;..@     double weight (987.654)</code></pre><h1>Conclusions</h1></main><footer>Last modified May 22 00:01:42 2021</footer></body></html>