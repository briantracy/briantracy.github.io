<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Brian C Tracy Brown University Palo Alto personal website programmer Brian Tracy - bperf"><title>Brian Tracy - bperf</title><link href="data:," rel="icon"><style>main{margin:auto;max-width:48em}pre{background-color:#d3d3d3;padding:1em}code{background-color:#d3d3d3}footer{font-style:italic;margin-top:3em}hr{width:60%}h1,h2,h3,h4,h5{color:#006400}table{border-collapse:collapse;border-spacing:0}th,td{border:2px solid silver;padding:4px}</style></head><body><main><h1>bperf &mdash; Bad Performance Profiler</h1><p>This writeup will walk through the implementation of a basic performance profiler for C programs.</p><h3>Motivation</h3><p>One of the more interesting topics I learned about in school is Linux's dynamic loader (<code>ld.so</code>). Symbol resolution (the act of converting a symbol's textual name to its address) seemed especially fascinating and I wanted to make use of it in a project. By combining the dynamic loader with frequent interrupts, I thought I could gauge the performance of a program by periodically determining which function was currently executing.</p><h3>Goals</h3><p>Ideally I would be able to modify a program minimally (just add a call to <code>perf_start()</code> and <code>perf_stop()</code>), run it, then see a nice output telling me what parts of the program were running for the longest.</p><h3>Sampling Theory</h3><p>The theory behind a sampling profiler is fairly straightforward: if you want to know what a program is spending its time doing, all you have to do is ask! If you check in on the program periodically and mark down which function is currently executing, you will be able to paint a picture of which functions are "on the CPU" most often.</p><pre><code>                       (---&gt; Time ---&gt;)

samples: a  a  a  b  a  a  b  b  b  c  c  a  a  a  a  a
         |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
         v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v
        +-------+---+---+--------+-----+--------+-------+
        |   a   | b | a |    b   |  c  |    a   |   a   |
        +-------+---+---+--------+-----+--------+-------+
                        (Function on CPU)


Results:
    a - 10 ticks
    b - 4  ticks
    c - 2  ticks</code></pre><p>If you notice that you interrupted function <code>A</code> 5 times as often as function <code>B</code>, it follows that function <code>A</code> was being executed roughly for 5 times as long as function <code>B</code></p><p><em>Aside: It is worth noting that the sampling rate is critical to the accuracy of the final metrics. Consider a program that has two functions, <code>F</code> and <code>J</code>. <code>F</code> runs for 9ms, then <code>J</code> runs for 1ms. If you are sampling the program every 10ms and get "unlucky", you could interrupt the program only when <code>J</code> is running, and conclude that is was running 100% of the time. If you sampled once per 1ms, this error goes away.</em></p><p>To make this idea concrete, we can use software interrupts to "check in" on a program periodically, and instruction pointer tracking to see what program is being interrupted.</p><p>The high level algorithm looks like this:</p><pre><code>profile($program):
    map&lt;function,int&gt; samples
    every 10 ms:
        interrupt $program
        fn = $program-&gt;last_executed_function
        samples[fn]++
        resume $program</code></pre><h3>First Attempt</h3><p>The first problem I wanted to solve was determining what function was interrupted while executing inside a signal handler.</p><p>I recalled hearing an anecdote from my operating systems professor about how the adoption of Non-eXecutable Memory (often referred to as NX) broke some operating systems due to the way they were handling signals. The design was that whenever a signal had to be sent to a process that did not have a user defined handler, the code of the default handler would literally be pushed on to the userspace stack and then executed.</p><p>Remembering this, I thought that maybe the current implementation (which definitely did not use executable code on the stack) might still have access to the user's stack through the base pointer (stack unwinding). If I could get access to the saved registers of the interrupted process inside of an interrupt handler, I could track the instruction pointer.</p><p>Unfortunately, it appears that in modern versions of Linux, signal handlers are executed in a separate region of the stack and I could not find a way to reliably gain access to the "main" stack. In addition, it seems that upon interrupt, registers are spilled to a separate kernel stack that would be totally inaccessible to the interrupt handler.</p><h3>Man Page Hunting</h3><p>After I verified via <code>gdb</code> that I could not partially "unwind" the interrupt stack to get to the interrupted function, I let the project go for a few weeks. Eventually, after much searching, I ran across a stack overflow post that had a very interesting code example that made everything possible.</p><p>It turns out that the <code>sigaction</code> structure that is passed into the <code>sigaction</code> syscall (to install an interrupt handler) can receive a flag of <code>SA_SIGINFO</code> that tells the kernel to pass the context of the interrupted process into the signal handler. The man page for <code>sigaction</code> has great information on this.</p><h3>Accessing the Instruction Pointer</h3><p>With the correct flag to <code>sigaction</code>, our interrupt handler is now a three argument function whose final arg can be cast to a magical <code>ucontext_t *</code>.</p><p>After implementing a tiny OS as an assignment in school, I was positive that such a structure should exist. The first instructions of the kernel's hardware interrupt handler looked like <code>push %reg1; ... ; push %regN</code>, so all the data I was after had to be somewhere. Finding this data though took 95% of the total project time.</p><p>Here is the syntax for poking into the <code>ucontext_t</code> structure.</p><pre><code>void handler(int signum, siginfo_t *info, void *ctx) {
    // lol @ &quot;greg&quot;
    greg_t const rip = ((ucontext_t *)ctx)-&gt;uc_mcontext.gregs[REG_RIP];
    ...</code></pre><h3>Mapping %rip -&gt; symbol (<code>ld.so</code>)</h3><p>Now that I could determine the instruction pointer just prior to the interrupt, I had to convert this to a function name. This is where the dynamic loader comes into play. The <code>dladdr</code> function (not POSIX, GNU specific) asks the dynamic loader to find the closest symbol <strong>below</strong> the given address. While we are executing a function, this "closest symbol below" will be the name of the function.</p><pre><code>Dl_info info;
int const s = dladdr((void *)rip, &amp;info);
const char *const function_name = info.dli_sname;</code></pre><p><em>Aside: <code>dladdr</code> returns 1 on success and 0 on failure. Yikes</em></p><h3>Keeping Track (async-signal-safely)</h3><p>Now that we have the name of the function currently on the CPU at every interrupt, we need to keep track of this data.</p><p>Originally, I was thinking of rolling my own hash map implementation (as an exercise) to map the <code>const char *</code> of a function's name to the <code>int</code> number of times it has been called. This started out fine, but then I realized that all bookkeeping code was being executed inside of a signal handler, which meant that the number of library functions I could call was extremely limited.</p><p>For example, I was planning on using <code>malloc</code> to create the hash entries, but you can't call that function as it is not signal safe. To get around this, I took the easy way out and statically allocated space for 100 entries and got on with it. The performance is bad (to record a call, you have to iterate through all the existing entries), but it works.</p><h3>API</h3><p>Now that the data collection is done, here is the public API for <code>bperf</code>:</p><pre><code>void bperf_start();   // install signal handler, start timer
void bperf_stop();    // uninstall signal handler
void bperf_display(); // prints output / graphs</code></pre><h3>Benchmark</h3><p>With the profiler in a working state, I needed a benchmark program to run it on. It needed to be CPU bound and have obviously bottlenecked functions, so I came up with the following scheme.</p><p>Create four functions called <code>tinywork</code>, <code>leastwork</code>, <code>middlework</code>, <code>mostwork</code>, each of which is essentially a busy CPU loop where a counter is incremented to a large number. <code>tinywork</code> runs for <code>1&lt;&lt;20</code> iterations, <code>leastwork</code> for 8x as many (<code>1&lt;&lt;23</code>), <code>middlework</code> for twice as many as <code>leastwork</code>, and <code>mostwork</code> for twice as many as <code>middlework</code>. Finally, there is <code>in_kernel</code> which just reads a huge number of bytes from <code>/dev/urandom</code>.</p><p>Each of these functions is called 10 times while the program is being profiled. We expect to see nearly linear scaling in CPU time between the <code>*work</code> functions as they are all doing the same thing, just for different amounts of time.</p><h3>Output</h3><pre><code>$ ./bench
bperf tracked 5 functions with 679 total samples
      name  | #calls | %calls | graphic
   tinywork   11       1.62    [          ]
  leastwork   89       13.11   [#         ]
 middlework   180      26.51   [##        ]
   mostwork   366      53.90   [#####     ]
     __read   33       4.86    [          ]</code></pre><p>Wow! The resulting percentages are almost exactly in the series that was expected: 8x, 2x, 2x, 2x!</p><p>Also, note the precision of the measurements. <code>bperf</code> can pick up a wide range from over 50% all the way down to 1%, so we are not "losing" anything to the noise.</p><h3>Conclusion</h3><p>For this use case, sampling based profilers are extremely accurate! However, I have doubts that this naive method would generalize well to real programs due to pesky things like mulithreading, multicore processing, and signal masking.</p><p>Thanks for following along, as always, the <a href="https://github.com/briantracy/systemb/tree/master/bperf">full source code is online</a>.</p></main><footer>Last modified Aug 31 19:42:47 2022</footer></body></html>