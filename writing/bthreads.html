<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Brian Tracy Brown University Palo Alto personal website"><title>Brian Tracy - bthreads</title><link href="data:," rel="icon"><style>main{margin-left:auto;margin-right:auto;max-width:48em}pre{background-color:#d3d3d3;padding:1em}code{background-color:#d3d3d3}footer{font-style:italic}hr{width:60%}h1,h2,h3,h4,h5{color:#006400}table{border-collapse:collapse;border-spacing:0}th,td{border:2px solid silver;padding:4px}</style></head><body><main><h1>bthreads &mdash; Bad Threading Library</h1><p>This writeup will walk through how to make an extremely barebones threading library for programs running on Linux, without support from <code>pthreads</code> or the <code>futex</code> syscall.</p><h3>Motivation</h3><p>It appears to me that implementing something badly is the first step towards implementing something well, and since I want to learn more about systems programming, I thought I would give this a shot. Mutexes are very interesting and while I have experience using them, I have only briefly considered how to create them myself.</p><p>Of course, a mutex isn't very interesting if you don't have multiple threads of control competing for it, so in order to test the mutexes I was creating, I also needed a way to create threads. This inspired the rest of the "library".</p><p>Code snippets presented in this writeup are distilled versions of the full library. They capture the critical points, but if you want to follow along in full, <a href="https://github.com/briantracy/bthread">you can view the source here</a>.</p><h3>Setup</h3><p>I wanted the following three features in <code>bthreads</code>:</p><ol type="1"><li>The ability to create threads</li><li>The ability to join these threads</li><li>The ability to synchronize these threads via mutexes</li></ol><p>This pretty much dictates the public API of <code>bthreads</code> as follows:</p><pre><code>int  bthread_create(int (*thread_func)(void *), void *thread_arg);
void bthread_collect();

void bthread_mutex_lock(bthread_mutex *mtx);
void bthread_mutex_unlock(bthread_mutex *mtx);</code></pre><p>For the sake of simplicity, joining threads is done all at once in <code>bthread_collect</code>, which should be called by the main thread before it exits.</p><h3>Creating Threads</h3><p>The goal of threads is to have multiple concurrent instruction streams, all with the capability of accessing a shared piece of memory. One method for accomplishing this would be to use <code>fork</code> to create a new process for each thread, then use <code>mmap</code> to map in a shared memory region into each process' address space.</p><p>Instead of doing this ourselves, we can utilize the <code>clone</code> system call (more precisely, the glibc wrapper) and let the kernel handle the process creation and memory sharing.</p><p><em>Aside: I have read that the process vs thread distinction is really a user space abstraction, and that the kernel sees both types of objects as simply "tasks". Assuming this is true, allowing the kernel to manage thread creation sees like a much better idea than a hacky <code>fork</code>+<code>mmap</code> approach</em></p><p>With <code>clone</code>, thread creation distills down to a single call of the following form:</p><pre><code>int child_pid = clone(
    thread_func, (void *)stack_top,
    CLONE_VM | SIGCHLD,
    thread_arg
);</code></pre><p><code>thread_func</code> is the function the user would like to run in the new thread, <code>stack_top</code> points to a region of the address space that was previously allocated for this thread to run inside of, and the flags passed in are as follows:</p><ol type="1"><li><code>CLONE_VM</code>: Tells the kernel to run this thread in the same address space as the one in which it was created. This is where the classical thread vs process distinction is made.</li><li><code>SIGCHLD</code> tells the kernel to ensure that when the newly created thread exits, <code>SIGCHLD</code> should be sent to the parent. This allows the parent to <code>wait</code> upon the child as if it were a process.</li></ol><p>So now we have the capability to fracture one address space into many stacks, have a thread running on each stack, and have all the threads access the same shared memory.</p><h3>Joining Threads</h3><p>Before the main thread (the one that spawned all the others via <code>btrhread_create</code>) exits, we would like all of the children to terminate. A common description of this action would be to say that we want to have the parent thread "join with" the child threads (see <code>pthread_join</code>).</p><p>Due to the thread/process duality that is a result of <code>clone</code>, we can leverage the standard <code>wait</code> family of system calls to simulate joining with threads.</p><p>Assuming we have a list of the pids from all of the <code>clone</code> calls (<code>thread_ids</code> below), as well as the total number of threads created (<code>next_tid</code> below), we can repeatedly call <code>wait</code> to collect all of them.</p><pre><code>for (int i = 0; i &lt; next_tid; i++) {
    int status;
    if (waitpid(thread_ids[i], &amp;status, 0) == -1) {
        fprintf(stderr, &quot;... failed to join with thread %d\n&quot;, i);
    }
    fprintf(stderr, &quot;... thread %i exited with value %d\n&quot;, i, WEXITSTATUS(status));
}</code></pre><p><em>Aside: Technically, the call to <code>WEXITSTATUS</code> has no meaning unless the process cleanly exited (as apposed to being killed by a signal), but this is glossed over for simplicity's sake</em></p><p>Now our threads can be spawned, and then reigned in when they are done working. We can now move on to synchronizing the threads during their execution.</p><h3>Implementing Mutexes</h3><p>To implement a mutex, we need some help from the hardware (<em>Note: this is false in certain situations: <a href="https://en.wikipedia.org/wiki/Peterson%27s_algorithm" class="uri">https://en.wikipedia.org/wiki/Peterson%27s_algorithm</a></em>). x86 provides the <code>lock</code> prefix for instructions, which allows atomic memory access.</p><h3>Sample Program</h3><h3>Performance</h3><h3>Resources</h3><p>https://eli.thegreenplace.net/2018/launching-linux-threads-and-processes-with-clone/</p></main><footer>Last modified May 19 13:38:06 2020</footer></body></html>