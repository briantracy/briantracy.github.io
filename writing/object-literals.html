<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Brian Tracy Brown University Palo Alto personal website"><title>Brian Tracy - object-literals</title><link href="data:," rel="icon"><style>main{margin:auto;max-width:48em}pre{background-color:#d3d3d3;padding:1em}code{background-color:#d3d3d3}footer{font-style:italic;margin-top:3em}hr{width:60%}h1,h2,h3,h4,h5{color:#006400}table{border-collapse:collapse;border-spacing:0}th,td{border:2px solid silver;padding:4px}</style></head><body><main><h1>ECMAScript 2015 "Enhanced Object Literals" are an anti-pattern</h1><p><em>This is an opinion.</em></p><p>Consider the following function written using the relatively new JavaScript feature of <a href="https://www.sitepoint.com/es6-enhanced-object-literals/">"Enhanced Object Literals"</a>.</p><pre><code>// Authentication API requires a POST body in the form
//      {&quot;username&quot;: &quot;string&quot;, &quot;password&quot;, &quot;string&quot;}
function createApiParameters(username, password) {
    return {
        username,
        password    
    };
}

createApiParameters(&#39;david&#39;, &#39;123&#39;);
// { username: &#39;david&#39;, password: &#39;123&#39; }</code></pre><p>Now, what would happen if we performed a refactor and changed our local variable of <code>username</code> to <code>user_name</code>. An application of The Principle of Least Astonishment tells us that changing the name of a function's argument should have <strong>zero</strong> effect on the output of that function.</p><p><img style="display:block; margin-left: auto; margin-right: auto;" alt="Refactoring code" src="/images/es6_object_refactor.gif"></p><pre><code>createApiParameters(&#39;david&#39;, &#39;123&#39;);
// { user_name: &#39;david&#39;, password: &#39;123&#39; }</code></pre><p>Oh no! Using this new syntax, we have assigned semantic meaning to the literal names of our variables, which in my opinion, is awful. Variable names should serve only as placeholders, not syntactic objects that also carry around metadata about their name.</p><p>Real Life&TRADE; examples are often more subtle than the one above. For example, your return statement might be 20 lines from your argument list, making the connection between the two invisible at first glance. For this reason, I will be sticking with the old syntax when creating dictionaries whose keys need to follow a strict contract.</p><pre><code>return {
    username: username,
    password: password
};</code></pre><p><em>Side Note: The popular linting library ESLint do not currently have a rule to detect the usage of this language feature. I am considering creating an issue in their system for this.</em></p><p><em>Side Note': The Visual Studio Code editor, when performing a literal textual replacement reproduces the behavior described above. However, when using the built in refactor tool, it is smart enough to avoid changing the name of the object keys. However, my point still stands that a symbolic change to the source should not have a difference on output.</em></p></main><footer>Last modified Aug 2 22:50:13 2020</footer></body></html>