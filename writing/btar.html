<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Brian C Tracy Brown University Palo Alto personal website Brian Tracy - btar"><title>Brian Tracy - btar</title><link href="data:," rel="icon"><style>main{margin:auto;max-width:48em}pre{background-color:#d3d3d3;padding:1em}code{background-color:#d3d3d3}footer{font-style:italic;margin-top:3em}hr{width:60%}h1,h2,h3,h4,h5{color:#006400}table{border-collapse:collapse;border-spacing:0}th,td{border:2px solid silver;padding:4px}</style></head><body><main><h1>btar &mdash; Bad tar Clone</h1><p>This writeup will walk through how to create a clone (ish) of the classic UNIX <code>tar</code> command, with one additional feature.</p><h3>Motivation</h3><p>Consider the following quote from the Wikipedia page for <code>tar</code>:</p><p><em>The tar format was designed without a centralized index or table of contents for files and their properties for streaming to tape backup devices. The archive must be read sequentially to list or extract files. For large tar archives, this causes a performance penalty, making tar archives unsuitable for situations that often require random access to individual files.</em></p><p>I read this and thought, "wow that seems like an oversight", and then, with the hubris of a recent college graduate, I thought "I can do better".</p><h3><code>tar</code> Overview</h3><p><code>tar</code> converts a set of files into a single file. This new file, known as an "archive" (hence the name <strong>t</strong>ape <strong>ar</strong>chive) can later be converted back into the original set of files.</p><p>One of the great things about files is that they are just bytes, so to amalgamate a set of files, all you really have to do is concatenate their contents. Add in some metadata about which file starts where, and this is pretty much it.</p><h3>Design Overview</h3><p>Random access was the one feature I wanted to add, so I had this in mind when beginning the design process. To get random access to a given file in the archive, I would have to know where all the files are without reading the entire archive.</p><p>We can model this information with a method that is extremely similar to the concept of <a href="https://en.wikipedia.org/wiki/Extent_(file_systems)">Extents</a> in file systems. Essentially, each file is identified in the archive by a tuple of <code>(offset, length)</code>, and all of these tuples are stored at the head of the file.</p><p>All you need now is a way to associate a file name with a single tuple, and the archive is complete.</p><h3>File Names</h3><p>Most of the <code>tar</code> implementations I have read about have all had fixed length requirements for file names. The benefit to having a maximum file length is that it simplifies the layout of metadata. The downside is that you now have an upper bound on the name of a file, which is normally much smaller than the real upper bound provided by the OS. In addition, fixed length file name fields lead to wasted space when the majority of your files have short names.</p><p><code>btar</code> stores file names separately from extent metadata. Much like how a compiler will separate code and data, the archive separates all fixed length and variable length data. In both cases, it is not necessary, but makes things easier down the line.</p><h3>Archive Format</h3><p>The <code>btar</code> archive is structured as follows:</p><ol type="1"><li><p><strong>Archive Header:</strong> The archive header contains a magic number that identifies the file as a <code>btar</code> archive (the sequence of bytes <code>"\x9a\x00\xA1\xFC""btar"</code>). In addition, it stores when the archive was created, how many files are in it, and the total length of all metadata (that is, all data that is not actual file data).</p></li><li><p><strong>File Metadata Blocks:</strong> After the archive header comes the list of <code>(offset, length)</code> tuples for each file. The number tuples is known from the archive header.</p></li><li><p><strong>File Names:</strong> Next comes all of the file names. They are stored as consecutive NULL terminated strings, and can be of any length.</p></li><li><p><strong>File Data:</strong> Finally, the raw data of every file is concatenated together. There is no separation between the bytes of two files (unlike <code>tar</code>) as the offsets between them are known.</p></li></ol><p>Here is a comment from the top of <code>btar.h</code> giving a visual description of the format.</p><pre><code>/*
 *        BTAR ARCHIVE FORMAT
 * +-----------------------------------+
 * | +-------------------------------+ |
 * | | Magic Number (8 bytes)        | |
 * | | Creation Date (8 bytes)       | |   One master block
 * | | Number of Files (8 bytes)     | |
 * | | Total Header Length (8 bytes) | |
 * | +-------------------------------+ |
 * |                                   |
 * | +------------------------------+  |
 * | | +--------------------------+ |  |
 * | | | File Length (8 bytes)    | |  |   Many file metadata blocks
 * | | | Archive Offset (8 bytes) | |  |   (one per file in archive)
 * | | +--------------------------+ |  |
 * | |            ...               |  |
 * | |            ...               |  |
 * | |            ...               |  |
 * | +------------------------------+  |
 * |                                   |
 * | +---------------+                 |
 * | | &quot;filename1&quot;\0 |                 |   Null terminated file names
 * | | &quot;filename2&quot;\0 |                 |   (one per file in archive)
 * | |    ...        |                 |
 * | | &quot;filenameN&quot;\0 |                 |
 * | +---------------+                 |
 * |                                   |
 * |           (end of header)         |
 * |                                   |
 * | +-------------------------------+ |
 * | |                               | |  Bytes of files in archive
 * | |         Raw File Data         | |  (one extent per file)
 * | |                               | |  (indexed by metadata blocks)
 * | +-------------------------------+ |
 * +-----------------------------------+
 *
*/</code></pre><h3>Implementation</h3><p>Here is the process for extracting a file from the archive:</p><ol type="1"><li>Open the file and read the first <code>sizeof(struct archive_header)</code> bytes.</li><li>Skip ahead <code>num_files * sizeof(struct file_metadata)</code> bytes to skip of the extent tuples to get to the file names.</li><li>Read all of the file names into memory (we know the total length of all the file names from the archive header).</li><li>Search for the given file name to extract. Because all the file names are are NULL terminated, it is easy to figure out the index of a given file name.</li><li>With the index of the desired file, look into the extent list and find the offset and length of the file.</li><li>Seek to the proper offset, read the correct number of bytes, and write them to a file.</li></ol><p>To create an archive from a set of files:</p><ol type="1"><li>Open all the files first to make sure they exist and are readable.</li><li>Compute how large the archive metadata will be based off of the length of all file names and how many files there are.</li><li>Seek past all the metadata and transfer all of the files contiguously into the archive.</li><li>Seek to the beginning of the file and write the metadata.</li></ol><h3>2038 Problem</h3><h3>Usage</h3><p>Here is the API for <code>btar</code></p><pre><code> $ ./btar
btar -- usage

o To create an archive from a set of files:
  &gt; btar pack archive [file1 ... fileN]

o To extract all (or certain) files from an archive:
  &gt; btar unpack archive [file1 ... fileN]

o To view the contents of an archive:
  &gt; btar list archive</code></pre></main><footer>Last modified Apr 26 23:23:43 2021</footer></body></html>